require("dotenv").config();
const express = require("express");
const { createClient } = require("@supabase/supabase-js");
const cors = require("cors");
const axios = require("axios");
const multer = require("multer");
const jwt = require("jsonwebtoken");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const bcrypt = require("bcrypt");
const path = require("path");
const fs = require("fs");
const winston = require("winston");
const cookieParser = require("cookie-parser");
const cron = require("node-cron");
const dayjs = require("dayjs");
const isBetween = require("dayjs/plugin/isBetween");
dayjs.extend(isBetween);
const moment = require("moment");

const app = express();
const PORT = process.env.PORT || 3001;
const saltRounds = 10;
const userInputStatus = {};

if (
  !process.env.SUPABASE_KEY ||
  !process.env.LINE_ACCESS_TOKEN ||
  !process.env.JWT_SECRET
) {
  console.error("‚ùå Missing required environment variables!");
  process.exit(1);
}
// ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö Supabase
const supabaseUrl = process.env.SUPABASE_URL;
const supabaseKey = process.env.SUPABASE_KEY;
const supabase = createClient(supabaseUrl, supabaseKey);
const LINE_ACCESS_TOKEN = process.env.LINE_ACCESS_TOKEN;
const LINE_CHANNEL_SECRET = process.env.LINE_CHANNEL_SECRET;

app.use(helmet());
app.set("trust proxy", 1); // ‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô trust proxy



// ‡πÉ‡∏ä‡πâ middleware ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö parsing JSON ‡πÅ‡∏•‡∏∞ URL-encoded data
app.use(express.json()); // ‡πÉ‡∏ä‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö parsing JSON body
app.use(express.urlencoded({ extended: true })); // ‡πÉ‡∏ä‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö parsing x-www-form-urlencoded body

// ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ winston logger
const logger = winston.createLogger({
  level: "info",
  transports: [
    new winston.transports.Console(),
    new winston.transports.File({ filename: "logfile.log" }),
  ],
});
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 100,
  message: "Too many requests, please try again later.",
});
app.use(limiter);

// üåç CORS Configuration (‡∏à‡∏≥‡∏Å‡∏±‡∏î origin)
const corsOptions = {
  origin: process.env.CORS_ALLOWED_ORIGINS?.split(",") || "*",
  methods: ["GET", "POST", "DELETE", "PUT"],
  credentials: true,
  allowedHeaders: "Content-Type,Authorization",
};
app.use(cors(corsOptions));
app.use(express.json());

// ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô SQL Injection ‡πÅ‡∏•‡∏∞‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡πà‡∏≠‡∏ô‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô
const sanitizeInput = (input) => {
  if (typeof input !== "string") return "";
  return input.replace(/[^\w\s@.-]/gi, ""); // ‡∏•‡∏ö‡∏≠‡∏±‡∏Å‡∏Ç‡∏£‡∏∞‡∏ó‡∏µ‡πà‡∏≠‡∏±‡∏ô‡∏ï‡∏£‡∏≤‡∏¢
};

//‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå
app.get("/", (req, res) => {
  res.json({ message: "Server is online" });
});

//‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÇ‡∏õ‡∏£‡πÑ‡∏ü‡∏•‡πå
app.get("/getProfile", async (req, res) => {
  try {
    const token = req.headers.authorization?.split(" ")[1];
    if (!token) return res.status(401).json({ message: "Unauthorized" });

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö JWT Token
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    if (!decoded.username)
      return res.status(403).json({ message: "Invalid token" });

    // sanitize input
    const username = sanitizeInput(req.query.username);

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å Supabase
    const { data, error } = await supabase
      .from("medicalpersonnel")
      .select("*")
      .eq("username", username) // ‡πÉ‡∏ä‡πâ username ‡∏ó‡∏µ‡πà sanitize ‡πÅ‡∏•‡πâ‡∏ß
      .single();

    if (error)
      return res.status(500).json({ message: "Error fetching profile" });

    res.json(data);
  } catch (err) {
    res.status(500).json({ message: "Server error", error: err.message });
  }
});

// Login ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Admin ‡πÅ‡∏•‡∏∞ Medical Personnel
app.post("/login", async (req, res) => {
  const { username, password } = req.body;

  if (!username || !password)
    return res.status(400).json({ message: "Missing username or password." });

  try {
    const cleanUsername = sanitizeInput(username);
    const tables = ["admins", "medicalpersonnel"];

    for (const table of tables) {
      let { data: user, error } = await supabase
        .from(table)
        .select("*")
        .eq("username", cleanUsername)
        .single();
      if (!error && user) {
        const isMatch = await bcrypt.compare(password, user.password);
        if (isMatch) {
          // ‡∏™‡∏£‡πâ‡∏≤‡∏á JWT Token
          const token = jwt.sign(
            { username: user.username, role: table },
            process.env.JWT_SECRET,
            { expiresIn: "2h" }
          );

          // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ cookie ‡πÄ‡∏õ‡πá‡∏ô HTTP-only
          res.cookie("token", token, {
            httpOnly: true, // ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡∏à‡∏≤‡∏Å JavaScript
            secure: process.env.NODE_ENV === "production", // ‡πÉ‡∏ä‡πâ HTTPS ‡πÉ‡∏ô production
            maxAge: 2 * 60 * 60 * 1000, // ‡πÉ‡∏ä‡πâ‡πÄ‡∏ß‡∏•‡∏≤ 2 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á
          });

          return res.json({
            message: "Login Success",
            user: { username: user.username, role: table },
          });
        } else {
          return res.status(401).json({ message: "Invalid password" });
        }
      }
    }
    return res.status(404).json({ message: "User not found" });
  } catch (err) {
    return res
      .status(500)
      .json({ message: "Internal Server Error", error: err.message });
  }
});

// ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏° personnel ‡πÉ‡∏´‡∏°‡πà
app.post("/medical-personnel", async (req, res) => {
  try {
    const {
      username,
      password,
      name,
      position,
      expertise,
      affiliation,
      email,
    } = req.body;
    if (
      !username ||
      !password ||
      !name ||
      !position ||
      !expertise ||
      !affiliation ||
      !email
    ) {
      return res
        .status(400)
        .json({ message: "Please provide all required fields." });
    }

    // ‚úÖ Hash ‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡∏Å‡πà‡∏≠‡∏ô‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å
    const hashedPassword = await bcrypt.hash(password, saltRounds);

    // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡∏á‡πÉ‡∏ô Supabase
    const { data, error } = await supabase.from("medicalpersonnel").insert([
      {
        username,
        password: hashedPassword, // ‡πÉ‡∏ä‡πâ‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å hash ‡πÅ‡∏•‡πâ‡∏ß
        name,
        nickname,
        position,
        expertise,
        affiliation,
        email,
      },
    ]);

    if (error)
      return res
        .status(500)
        .json({ message: "Error adding personnel", error: error.message });

    return res
      .status(201)
      .json({ message: "Personnel added successfully", data });
  } catch (err) {
    return res
      .status(500)
      .json({ message: "Server error", error: err.message });
  }
});

// ‚úÖ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ä‡πà‡∏ß‡∏¢‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÑ‡∏õ‡∏¢‡∏±‡∏á LINE
async function sendLineMessage(replyToken, messageText) {
  try {
    await axios.post(
      "https://api.line.me/v2/bot/message/reply",
      {
        replyToken: replyToken,
        messages: [{ type: "text", text: messageText }],
      },
      {
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${LINE_ACCESS_TOKEN}`,
        },
      }
    );
  } catch (error) {
    console.error("Error sending message to LINE:", error);
    throw new Error("Unable to send message to LINE");
  }
}

async function insertPatientData(lineUserId, data) {
  try {
    const { data: insertedData, error } = await supabase
      .from("patient")
      .insert([{ lineid: lineUserId, ...data }]);

    if (error) throw error;
    return true;
  } catch (error) {
    console.error("Error inserting patient data:", error.message);
    return false;
  }
}

const handleUserMessage = async (event, messageText) => {
  const lineUserId = event.source.userId;

  if (messageText === "‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ") {
    userInputStatus[lineUserId] = { step: "name", data: {} };
    await sendLineMessage(event.replyToken, "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏ä‡∏∑‡πà‡∏≠‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì");
    return;
  }

  if (userInputStatus[lineUserId]) {
    const currentStep = userInputStatus[lineUserId].step;
    const userData = userInputStatus[lineUserId].data;

    switch (currentStep) {
      case "name":
        userData.name = messageText;
        userInputStatus[lineUserId].step = "email";
        await sendLineMessage(event.replyToken, "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì");
        break;
      case "email":
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (!emailRegex.test(messageText)) {
          await sendLineMessage(event.replyToken, "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡πÉ‡∏´‡πâ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á");
          return;
        }
        userData.email = messageText;
        userInputStatus[lineUserId].step = "phone";
        await sendLineMessage(event.replyToken, "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡πÄ‡∏ö‡∏≠‡∏£‡πå‡πÇ‡∏ó‡∏£‡∏®‡∏±‡∏û‡∏ó‡πå‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì");
        break;
      case "phone":
        if (isNaN(messageText)) {
          await sendLineMessage(
            event.replyToken,
            "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏ö‡∏≠‡∏£‡πå‡πÇ‡∏ó‡∏£‡∏®‡∏±‡∏û‡∏ó‡πå"
          );
          return;
        }
        userData.tel = messageText;
        userInputStatus[lineUserId].step = "address";
        await sendLineMessage(event.replyToken, "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì");
        break;
      case "address":
        userData.address = messageText;
        userInputStatus[lineUserId].step = "sickness";
        await sendLineMessage(event.replyToken, "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡πÇ‡∏£‡∏Ñ‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡∏ì‡πÄ‡∏õ‡πá‡∏ô‡∏≠‡∏¢‡∏π‡πà");
        break;
      case "sickness":
        userData.sickness = messageText;
        userInputStatus[lineUserId].step = "age";
        await sendLineMessage(event.replyToken, "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏≠‡∏≤‡∏¢‡∏∏‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì");
        break;
      case "age":
        if (isNaN(messageText)) {
          await sendLineMessage(event.replyToken, "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏≠‡∏≤‡∏¢‡∏∏‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç");
          return;
        }
        userData.age = messageText;
        userInputStatus[lineUserId].step = "allergic";
        await sendLineMessage(
          event.replyToken,
          "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏≤‡∏Å‡∏≤‡∏£‡πÅ‡∏û‡πâ (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ)"
        );
        break;
      case "allergic":
        userData.allergic = messageText;
        if (Object.values(userData).some((field) => !field)) {
          await sendLineMessage(
            event.replyToken,
            "‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏Ñ‡∏£‡∏ö ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÉ‡∏´‡∏°‡πà‡πÇ‡∏î‡∏¢‡∏û‡∏¥‡∏°‡∏û‡πå '‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ'"
          );
          return;
        }

        if (await insertPatientData(lineUserId, userData)) {
          await sendLineMessage(
            event.replyToken,
            "‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏ñ‡∏π‡∏Å‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß"
          );
          delete userInputStatus[lineUserId];
        } else {
          await sendLineMessage(
            event.replyToken,
            "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà"
          );
        }
        break;
      default:
        await sendLineMessage(
          event.replyToken,
          "‡∏û‡∏¥‡∏°‡∏û‡πå '‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ' ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏£‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡∏°‡πà‡∏Ñ‡∏£‡∏±‡∏ö"
        );
    }
  } else {
    await sendLineMessage(
      event.replyToken,
      "‡∏û‡∏¥‡∏°‡∏û‡πå '‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ' ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏£‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡∏°‡πà‡∏Ñ‡∏£‡∏±‡∏ö"
    );
  }
};

const verifySignature = (req) => {
  const signature = req.headers["x-line-signature"];
  if (!signature) throw new Error("Forbidden");
};

// ‚úÖ ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏à‡∏≤‡∏Å LINE Webhook
app.post("/webhook", async (req, res) => {
  try {
    console.log("üì© Received Webhook:", JSON.stringify(req.body, null, 2));

    // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢
    verifySignature(req);

    // ‚úÖ ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• events ‡∏à‡∏≤‡∏Å body
    const events = req.body.events;
    if (!events || events.length === 0) {
      console.log("‚ö†Ô∏è No events received");
      return res.status(400).send("No events received");
    }

    for (const event of events) {
      console.log("üîç Processing event:", event);
      const messageText = event.message?.text?.trim();

      if (messageText && event.message.type === "text") {
        await handleUserMessage(event, messageText);
      } else {
        console.log("‚úÖ Non-text message received");
        return res.status(200).send("OK");
      }
    }

    res.status(200).send("OK");
  } catch (error) {
    console.error("‚ùå Server error:", error);
    return res
      .status(500)
      .json({ message: "Server error", error: error.message });
  }
});

// API ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏ú‡∏π‡πâ‡∏õ‡πà‡∏ß‡∏¢
app.get("/search-patient", async (req, res) => {
  const { name } = req.query;

  if (!name) {
    return res.status(400).send("Name parameter is required");
  }

  try {
    const { data, error } = await supabase
      .from("patient")
      .select("*")
      .ilike("name", `%${name}%`); // ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏ä‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡∏õ‡πà‡∏ß‡∏¢‡πÅ‡∏ö‡∏ö‡πÑ‡∏°‡πà‡∏Ñ‡∏≥‡∏ô‡∏∂‡∏á‡∏ñ‡∏∂‡∏á‡∏ï‡∏±‡∏ß‡∏û‡∏¥‡∏°‡∏û‡πå‡πÉ‡∏´‡∏ç‡πà

    if (error) {
      return res.status(500).send(error.message);
    }

    res.status(200).json(data); // ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡∏õ‡πà‡∏ß‡∏¢‡∏ó‡∏µ‡πà‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤
  } catch (err) {
    res.status(500).send(err.message);
  }
});

// API ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏Å‡∏≤‡∏£‡∏ô‡∏±‡∏î‡∏´‡∏°‡∏≤‡∏¢
app.post("/set-appointment", async (req, res) => {
  try {
    const { patient_id, appointment_date, reminder_time } = req.body;

    // ‡∏û‡∏¥‡∏°‡∏û‡πå‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏à‡∏≤‡∏Å body ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö
    console.log("Request Body:", req.body);

    if (!patient_id) {
      return res
        .status(400)
        .json({ success: false, message: "Patient ID is required" });
    }

    const updateFields = {};
    if (appointment_date) updateFields.appointment_date = appointment_date;
    if (reminder_time) updateFields.reminder_time = reminder_time;

    // ‡∏´‡∏≤‡∏Å‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï
    if (Object.keys(updateFields).length === 0) {
      return res.status(400).json({
        success: false,
        message:
          "At least one of appointment_date or reminder_time must be provided",
      });
    }

    // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
    const { data, error } = await supabase
      .from("patient")
      .update(updateFields)
      .eq("patient_id", patient_id)
      .select();

    // ‡∏´‡∏≤‡∏Å‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏à‡∏≤‡∏Å Supabase
    if (error) {
      console.error("Supabase Error:", error);
      return res
        .status(500)
        .json({ success: false, message: "Database error", error });
    }

    // ‡∏´‡∏≤‡∏Å‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï
    if (data.length === 0) {
      return res.status(404).json({
        success: false,
        message: "Patient not found or no changes made",
      });
    }

    return res.json({
      success: true,
      message: "Appointment updated successfully",
      data,
    });
  } catch (err) {
    // ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° error ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ä‡πà‡∏ß‡∏¢‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏î‡∏µ‡∏ö‡∏±‡πä‡∏Å
    console.error("Server Error:", err);
    res
      .status(500)
      .json({ success: false, message: "Server error", error: err.message });
  }
});

app.get("/all-patients", async (req, res) => {
  try {
    // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡∏õ‡πà‡∏ß‡∏¢‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏à‡∏≤‡∏Å‡∏ï‡∏≤‡∏£‡∏≤‡∏á patient
    const { data, error } = await supabase.from("patient").select("*");

    if (error) {
      return res.status(500).send(error.message);
    }

    // ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡∏õ‡πà‡∏ß‡∏¢‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ
    res.status(200).json(data);
  } catch (err) {
    res.status(500).send(err.message);
  }
});

// API ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡∏õ‡πà‡∏ß‡∏¢
app.put("/update-patient", async (req, res) => {
  try {
    // ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏à‡∏≤‡∏Å‡∏Ñ‡∏≥‡∏Ç‡∏≠
    const { lineUserId, name, email, tel, address, sickness, age, allergic } =
      req.body;

    if (!lineUserId) {
      return res.status(400).json({ message: "Missing lineUserId" });
    }

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    const updates = {};
    if (name) updates.name = name;
    if (email) updates.email = email;
    if (tel) updates.tel = tel;
    if (address) updates.address = address;
    if (sickness) updates.sickness = sickness;
    if (age) updates.age = age;
    if (allergic) updates.allergic = allergic;

    // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô Supabase
    const { data, error } = await supabase
      .from("patient")
      .update(updates)
      .eq("lineid", lineUserId); // ‡πÉ‡∏ä‡πâ lineUserId ‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡∏£‡∏∞‡∏ö‡∏∏‡∏ú‡∏π‡πâ‡∏õ‡πà‡∏ß‡∏¢

    if (error) {
      return res
        .status(500)
        .json({ message: "Error updating patient data", error: error.message });
    }

    return res
      .status(200)
      .json({ message: "Patient data updated successfully", data });
  } catch (err) {
    return res
      .status(500)
      .json({ message: "Server error", error: err.message });
  }
});

app.post("/add-patient", async (req, res) => {
  try {
    const {
      name,
      age,
      lineid,
      allergic,
      sickness,
      address,
      tel,
      email,
      appointment_date,
    } = req.body;

    const { data, error } = await supabase
      .from("patient")
      .insert([
        {
          name,
          age,
          lineid,
          allergic,
          sickness,
          address,
          tel,
          email,
          appointment_date,
        },
      ])
      .select();

    if (error) {
      return res
        .status(500)
        .json({ message: "Error adding patient", error: error.message });
    }

    res.status(201).json(data[0]);
  } catch (err) {
    res.status(500).json({ message: "Server error", error: err.message });
  }
});

// API ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏•‡∏ö‡∏ú‡∏π‡πâ‡∏õ‡πà‡∏ß‡∏¢
app.delete("/delete-patient/:id", async (req, res) => {
  const { id } = req.params;
  try {
      const { error } = await supabase
          .from("patient")
          .delete()
          .eq("patient_id", id);

      if (error) {
          return res.status(500).json({ message: "Error deleting patient", error: error.message });
      }

      res.status(200).json({ message: "Patient deleted successfully" });
  } catch (err) {
      res.status(500).json({ message: "Server error", error: err.message });
  }
});
app.delete("/delete-patients", async (req, res) => {
  try {
      const { patientIds } = req.body;
      if (!patientIds || !Array.isArray(patientIds) || patientIds.length === 0) {
          return res.status(400).json({ message: "Invalid patient IDs" });
      }

      const { error } = await supabase
          .from("patient")
          .delete()
          .in("patient_id", patientIds);

      if (error) {
          return res.status(500).json({ message: "Error deleting patients", error: error.message });
      }

      res.status(200).json({ message: "Patients deleted successfully" });
  } catch (err) {
      res.status(500).json({ message: "Server error", error: err.message });
  }
});



const storage = multer.memoryStorage();
const upload = multer({ storage: multer.memoryStorage() });

app.post("/upload-file", upload.array("files"), async (req, res) => {
  try {
    const { patient_id } = req.body; // ‡∏£‡∏±‡∏ö‡πÄ‡∏â‡∏û‡∏≤‡∏∞ patient_id
    const files = req.files; // ‡∏£‡∏±‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ patient_id ‡∏°‡∏µ‡∏Ñ‡πà‡∏≤‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    if (!patient_id) {
      return res.status(400).json({ success: false, message: "Missing patient_id" });
    }

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÑ‡∏ü‡∏•‡πå‡∏ñ‡∏π‡∏Å‡∏™‡πà‡∏á‡∏°‡∏≤‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    if (!files || files.length === 0) {
      return res.status(400).json({ success: false, message: "No files uploaded" });
    }

    console.log(`patient_id: ${patient_id}`);

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ patient_id ‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    const { data: patient, error: patientError } = await supabase
      .from("patient")
      .select("id")
      .eq("id", patient_id)
      .single();

    if (patientError || !patient) {
      return res.status(400).json({ success: false, message: "Invalid patient_id" });
    }

    // ‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå (‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£)
    for (const file of files) {
      const filePath = `bucket888/${file.originalname}`;
      const { data, error } = await supabase.storage
        .from("bucket888")
        .upload(filePath, file.buffer, {
          contentType: file.mimetype,
        });

      if (error) {
        // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏•‡∏á‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á upload_logs
        await supabase.from("upload_logs").insert([{
          file_name: file.originalname,
          file_path: filePath,
          status: "failed",
          error_message: error.message,
          patient_id: patient_id,
        }]);

        throw new Error(`Error uploading file ${file.originalname}: ${error.message}`);
      }

      // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡∏á‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á upload_logs
      await supabase.from("upload_logs").insert([{
        file_name: file.originalname,
        file_path: filePath,
        status: "success",
        patient_id: patient_id,
      }]);
    }

    res.status(200).json({ success: true, message: "Files uploaded and log recorded successfully!" });
  } catch (error) {
    console.error("Error uploading files or recording log:", error);

    // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏•‡∏á‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á upload_logs
    if (req.body.patient_id) {
      await supabase.from("upload_logs").insert([{
        patient_id: req.body.patient_id,
        status: "failed",
        error_message: error.message,
      }]);
    }

    res.status(500).json({ success: false, message: "Error uploading files or recording log" });
  }
});
app.delete("/delete/:fileId", async (req, res) => {
  const fileId = req.params.fileId;

  try {
    // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏ü‡∏•‡πå‡∏à‡∏≤‡∏Å‡∏ï‡∏≤‡∏£‡∏≤‡∏á patient_files
    const { data: fileData, error: fileError } = await supabase
      .from("patient_files")
      .select("file_path")
      .eq("file_id", fileId)
      .single();

    if (fileError) {
      throw new Error(`Failed to fetch file info: ${fileError.message}`);
    }

    // ‡∏•‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏à‡∏≤‡∏Å Supabase Storage
    const { data: deleteStorageData, error: deleteStorageError } =
      await supabase.storage.from("bucket888").remove([fileData.file_path]);

    if (deleteStorageError) {
      throw new Error(
        `Failed to delete file from storage: ${deleteStorageError.message}`
      );
    }

    // ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏ü‡∏•‡πå‡∏à‡∏≤‡∏Å‡∏ï‡∏≤‡∏£‡∏≤‡∏á patient_files
    const { data: deleteData, error: deleteError } = await supabase
      .from("patient_files")
      .delete()
      .eq("file_id", fileId);

    if (deleteError) {
      throw new Error(`Failed to delete file info: ${deleteError.message}`);
    }

    res
      .status(200)
      .json({ success: true, message: "File deleted successfully." });
  } catch (error) {
    res.status(500).json({ success: false, message: error.message });
  }
});

async function sendLineAppointment(userId, message) {
  try {
    await axios.post(
      "https://api.line.me/v2/bot/message/push",
      {
        to: userId,
        messages: [{ type: "text", text: message }],
      },
      {
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${LINE_ACCESS_TOKEN}`,
        },
      }
    );
    console.log(`‚úÖ ‡∏™‡πà‡∏á‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡∏ñ‡∏∂‡∏á ${userId}`);
  } catch (error) {
    console.error(
      `‚ùå ‡∏™‡πà‡∏á‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß‡∏ñ‡∏∂‡∏á ${userId}:`,
      error.response?.data || error.message
    );
  }
}

async function getPatientData() {
  const { data, error } = await supabase
    .from("patient") // ‡∏ä‡∏∑‡πà‡∏≠‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡πÉ‡∏ô Supabase
    .select("name, lineid, reminder_time, appointment_date"); // ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£

  if (error) {
    console.error("Error fetching patient data:", error);
    return [];
  }

  return data; // ‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡∏õ‡πà‡∏ß‡∏¢
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÅ‡∏•‡∏∞‡∏™‡πà‡∏á‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô
async function sendNotifications() {
  const today = dayjs().format("YYYY-MM-DD");
  const tomorrow = dayjs().add(1, "day").format("YYYY-MM-DD");

  const patients = await getPatientData(); // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡∏õ‡πà‡∏ß‡∏¢‡∏à‡∏≤‡∏Å Supabase

  const patientsToNotify = patients.filter(
    (patient) =>
      patient.lineid &&
      patient.reminder_time &&
      patient.appointment_date &&
      (patient.appointment_date === today ||
        patient.appointment_date === tomorrow)
  );

  console.log("üìå ‡∏ú‡∏π‡πâ‡∏õ‡πà‡∏ß‡∏¢‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô:", patientsToNotify);

  // ‡∏™‡πà‡∏á‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏ï‡∏≤‡∏°‡πÄ‡∏ß‡∏•‡∏≤
  for (const patient of patientsToNotify) {
    const { lineid, reminder_time, appointment_date } = patient;
    const [hours, minutes, seconds] = reminder_time.split(":");
    const reminderDateTime = dayjs(
      `${appointment_date} ${hours}:${minutes}:${seconds}`
    );

    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏∞‡∏¢‡∏∞‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏≠ (‡∏°‡∏¥‡∏•‡∏•‡∏¥‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ)
    const delay = reminderDateTime.diff(dayjs());

    if (delay > 0) {
      console.log(
        `‚è≥ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ï‡∏±‡πâ‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏™‡πà‡∏á‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡πÉ‡∏´‡πâ ${patient.name} ‡πÉ‡∏ô‡πÄ‡∏ß‡∏•‡∏≤ ${reminder_time}`
      );

      setTimeout(async () => {
        const message = `‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô: ‡∏Ñ‡∏∏‡∏ì‡∏°‡∏µ‡∏ô‡∏±‡∏î‡∏´‡∏°‡∏≤‡∏¢‡πÉ‡∏ô‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà ${appointment_date} ‡πÄ‡∏ß‡∏•‡∏≤ ${reminder_time}`;
        await sendLineAppointment(lineid, message); // ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÑ‡∏õ‡∏¢‡∏±‡∏á LINE
      }, delay);
    } else {
      console.log(`‚ùå ‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡∏ï‡∏±‡πâ‡∏á‡πÑ‡∏ß‡πâ‡∏ú‡πà‡∏≤‡∏ô‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö ${patient.name}`);
    }
  }
}

// ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô
sendNotifications();

// ‚úÖ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå
app.listen(PORT, () => {
  console.log(`üöÄ Server running on http://localhost:${PORT}`);
});