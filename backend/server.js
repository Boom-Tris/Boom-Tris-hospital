require("dotenv").config();
const express = require("express");
const { createClient } = require("@supabase/supabase-js");
const cors = require("cors");
const axios = require("axios");
const multer = require("multer");
const jwt = require("jsonwebtoken");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const bcrypt = require("bcrypt");
const path = require("path");
const fs = require("fs");
const winston = require("winston");
const cookieParser  =require("cookie-parser");

const app = express();
const PORT = process.env.PORT || 3001;
const saltRounds = 10;
const userInputStatus = {};

if (
  !process.env.SUPABASE_KEY ||
  !process.env.LINE_ACCESS_TOKEN ||
  !process.env.JWT_SECRET
) {
  console.error("‚ùå Missing required environment variables!");
  process.exit(1);
}
// ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö Supabase
const supabaseUrl = process.env.SUPABASE_URL;
const supabaseKey = process.env.SUPABASE_KEY;
const supabase = createClient(supabaseUrl, supabaseKey);
const LINE_ACCESS_TOKEN = process.env.LINE_ACCESS_TOKEN;
const LINE_CHANNEL_SECRET = process.env.LINE_CHANNEL_SECRET;

app.use(helmet());
app.set("trust proxy", 1); // ‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô trust proxy

// ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ winston logger
const logger = winston.createLogger({
  level: "info",
  transports: [
    new winston.transports.Console(),
    new winston.transports.File({ filename: "logfile.log" }),
  ],
});
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 100,
  message: "Too many requests, please try again later.",
});
app.use(limiter);

// üåç CORS Configuration (‡∏à‡∏≥‡∏Å‡∏±‡∏î origin)
const corsOptions = {
  origin: process.env.CORS_ALLOWED_ORIGINS?.split(",") || "*",
  methods: ["GET", "POST", "DELETE", "PUT"],
  credentials: true, 
  allowedHeaders: "Content-Type,Authorization",
};
app.use(cors(corsOptions));
app.use(express.json());

// ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô SQL Injection ‡πÅ‡∏•‡∏∞‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡πà‡∏≠‡∏ô‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô
const sanitizeInput = (input) => {
  if (typeof input !== "string") return "";
  return input.replace(/[^\w\s@.-]/gi, ""); // ‡∏•‡∏ö‡∏≠‡∏±‡∏Å‡∏Ç‡∏£‡∏∞‡∏ó‡∏µ‡πà‡∏≠‡∏±‡∏ô‡∏ï‡∏£‡∏≤‡∏¢
};

//‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå
app.get("/", (req, res) => {
  res.json({ message: "Server is online" });
});

//‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÇ‡∏õ‡∏£‡πÑ‡∏ü‡∏•‡πå
app.get("/getProfile", async (req, res) => {
  try {
    const token = req.headers.authorization?.split(" ")[1];
    if (!token) return res.status(401).json({ message: "Unauthorized" });

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö JWT Token
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    if (!decoded.username)
      return res.status(403).json({ message: "Invalid token" });

    // sanitize input
    const username = sanitizeInput(req.query.username);

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å Supabase
    const { data, error } = await supabase
      .from("medicalpersonnel")
      .select("*")
      .eq("username", username) // ‡πÉ‡∏ä‡πâ username ‡∏ó‡∏µ‡πà sanitize ‡πÅ‡∏•‡πâ‡∏ß
      .single();

    if (error)
      return res.status(500).json({ message: "Error fetching profile" });

    res.json(data);
  } catch (err) {
    res.status(500).json({ message: "Server error", error: err.message });
  }
});

// Login ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Admin ‡πÅ‡∏•‡∏∞ Medical Personnel
app.post("/login", async (req, res) => {
  const { username, password } = req.body;

  if (!username || !password)
    return res.status(400).json({ message: "Missing username or password." });

  try {
    const cleanUsername = sanitizeInput(username);
    const tables = ["admins", "medicalpersonnel"];

    for (const table of tables) {
      let { data: user, error } = await supabase
        .from(table)
        .select("*")
        .eq("username", cleanUsername)
        .single();
      if (!error && user) {
        const isMatch = await bcrypt.compare(password, user.password);
        if (isMatch) {
          // ‡∏™‡∏£‡πâ‡∏≤‡∏á JWT Token
          const token = jwt.sign(
            { username: user.username, role: table },
            process.env.JWT_SECRET,
            { expiresIn: "2h" }
          );
            
            
             
            
          // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ cookie ‡πÄ‡∏õ‡πá‡∏ô HTTP-only
          res.cookie("token", token, {
            httpOnly: true, // ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡∏à‡∏≤‡∏Å JavaScript
            secure: process.env.NODE_ENV === "production", // ‡πÉ‡∏ä‡πâ HTTPS ‡πÉ‡∏ô production
            maxAge: 2 * 60 * 60 * 1000, // ‡πÉ‡∏ä‡πâ‡πÄ‡∏ß‡∏•‡∏≤ 2 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á
          });

          return res.json({
            message: "Login Success",
            user: { username: user.username, role: table },
          });
        } else {
          return res.status(401).json({ message: "Invalid password" });
        }
      }
    }
    return res.status(404).json({ message: "User not found" });
  } catch (err) {
    return res
      .status(500)
      .json({ message: "Internal Server Error", error: err.message });
  }
});

// ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏° personnel ‡πÉ‡∏´‡∏°‡πà
app.post("/medical-personnel", async (req, res) => {
  try {
    const {
      username,
      password,
      name,
      position,
      expertise,
      affiliation,
      email,
    } = req.body;
    if (
      !username ||
      !password ||
      !name ||
      !position ||
      !expertise ||
      !affiliation ||
      !email
    ) {
      return res
        .status(400)
        .json({ message: "Please provide all required fields." });
    }

    // ‚úÖ Hash ‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡∏Å‡πà‡∏≠‡∏ô‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å
    const hashedPassword = await bcrypt.hash(password, saltRounds);

    // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡∏á‡πÉ‡∏ô Supabase
    const { data, error } = await supabase.from("medicalpersonnel").insert([
      {
        username,
        password: hashedPassword, // ‡πÉ‡∏ä‡πâ‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å hash ‡πÅ‡∏•‡πâ‡∏ß
        name,
        nickname,
        position,
        expertise,
        affiliation,
        email,
      },
    ]);

    if (error)
      return res
        .status(500)
        .json({ message: "Error adding personnel", error: error.message });

    return res
      .status(201)
      .json({ message: "Personnel added successfully", data });
  } catch (err) {
    return res
      .status(500)
      .json({ message: "Server error", error: err.message });
  }
});

// ‚úÖ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ä‡πà‡∏ß‡∏¢‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÑ‡∏õ‡∏¢‡∏±‡∏á LINE
async function sendLineMessage(replyToken, messageText) {
  try {
    await axios.post(
      "https://api.line.me/v2/bot/message/reply",
      {
        replyToken: replyToken,
        messages: [{ type: "text", text: messageText }],
      },
      {
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${LINE_ACCESS_TOKEN}`,
        },
      }
    );
  } catch (error) {
    console.error("Error sending message to LINE:", error);
    throw new Error("Unable to send message to LINE");
  }
}

async function insertPatientData(lineUserId, data) {
  try {
    const { data: insertedData, error } = await supabase
      .from("patient")
      .insert([{ lineid: lineUserId, ...data }]);

    if (error) throw error;
    return true;
  } catch (error) {
    console.error("Error inserting patient data:", error.message);
    return false;
  }
}

const handleUserMessage = async (event, messageText) => {
  const lineUserId = event.source.userId;

  if (messageText === "‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ") {
    userInputStatus[lineUserId] = { step: "name", data: {} };
    await sendLineMessage(event.replyToken, "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏ä‡∏∑‡πà‡∏≠‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì");
    return;
  }

  if (userInputStatus[lineUserId]) {
    const currentStep = userInputStatus[lineUserId].step;
    const userData = userInputStatus[lineUserId].data;

    switch (currentStep) {
      case "name":
        userData.name = messageText;
        userInputStatus[lineUserId].step = "email";
        await sendLineMessage(event.replyToken, "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì");
        break;
      case "email":
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (!emailRegex.test(messageText)) {
          await sendLineMessage(event.replyToken, "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡πÉ‡∏´‡πâ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á");
          return;
        }
        userData.email = messageText;
        userInputStatus[lineUserId].step = "phone";
        await sendLineMessage(event.replyToken, "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡πÄ‡∏ö‡∏≠‡∏£‡πå‡πÇ‡∏ó‡∏£‡∏®‡∏±‡∏û‡∏ó‡πå‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì");
        break;
      case "phone":
        if (isNaN(messageText)) {
          await sendLineMessage(
            event.replyToken,
            "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏ö‡∏≠‡∏£‡πå‡πÇ‡∏ó‡∏£‡∏®‡∏±‡∏û‡∏ó‡πå"
          );
          return;
        }
        userData.tel = messageText;
        userInputStatus[lineUserId].step = "address";
        await sendLineMessage(event.replyToken, "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì");
        break;
      case "address":
        userData.address = messageText;
        userInputStatus[lineUserId].step = "sickness";
        await sendLineMessage(event.replyToken, "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡πÇ‡∏£‡∏Ñ‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡∏ì‡πÄ‡∏õ‡πá‡∏ô‡∏≠‡∏¢‡∏π‡πà");
        break;
      case "sickness":
        userData.sickness = messageText;
        userInputStatus[lineUserId].step = "age";
        await sendLineMessage(event.replyToken, "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏≠‡∏≤‡∏¢‡∏∏‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì");
        break;
      case "age":
        if (isNaN(messageText)) {
          await sendLineMessage(event.replyToken, "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏≠‡∏≤‡∏¢‡∏∏‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç");
          return;
        }
        userData.age = messageText;
        userInputStatus[lineUserId].step = "allergic";
        await sendLineMessage(
          event.replyToken,
          "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏≤‡∏Å‡∏≤‡∏£‡πÅ‡∏û‡πâ (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ)"
        );
        break;
      case "allergic":
        userData.allergic = messageText;
        if (Object.values(userData).some((field) => !field)) {
          await sendLineMessage(
            event.replyToken,
            "‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏Ñ‡∏£‡∏ö ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÉ‡∏´‡∏°‡πà‡πÇ‡∏î‡∏¢‡∏û‡∏¥‡∏°‡∏û‡πå '‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ'"
          );
          return;
        }

        if (await insertPatientData(lineUserId, userData)) {
          await sendLineMessage(
            event.replyToken,
            "‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏ñ‡∏π‡∏Å‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß"
          );
          delete userInputStatus[lineUserId];
        } else {
          await sendLineMessage(
            event.replyToken,
            "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà"
          );
        }
        break;
      default:
        await sendLineMessage(
          event.replyToken,
          "‡∏û‡∏¥‡∏°‡∏û‡πå '‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ' ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏£‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡∏°‡πà‡∏Ñ‡∏£‡∏±‡∏ö"
        );
    }
  } else {
    await sendLineMessage(
      event.replyToken,
      "‡∏û‡∏¥‡∏°‡∏û‡πå '‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ' ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏£‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡∏°‡πà‡∏Ñ‡∏£‡∏±‡∏ö"
    );
  }
};

const verifySignature = (req) => {
  const signature = req.headers["x-line-signature"];
  if (!signature) throw new Error("Forbidden");
};

// ‚úÖ ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏à‡∏≤‡∏Å LINE Webhook
app.post("/webhook", async (req, res) => {
  try {
    // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢
    verifySignature(req);

    // ‚úÖ ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• events ‡∏à‡∏≤‡∏Å body
    const events = req.body.events;
    if (!events || events.length === 0)
      return res.status(400).send("No events received");

    for (const event of events) {
      const messageText = event.message?.text?.trim();
      if (messageText && event.message.type === "text") {
        await handleUserMessage(event, messageText);
      } else {
        return res.status(200).send("OK");
      }
    }

    res.status(200).send("OK");
  } catch (error) {
    return res
      .status(500)
      .json({ message: "Server error", error: error.message });
  }
});

// API ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏ú‡∏π‡πâ‡∏õ‡πà‡∏ß‡∏¢
app.get("/search-patient", async (req, res) => {
  const { name } = req.query;

  if (!name) {
    return res.status(400).send("Name parameter is required");
  }

  try {
    const { data, error } = await supabase
      .from("patient")
      .select("*")
      .ilike("name", `%${name}%`); // ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏ä‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡∏õ‡πà‡∏ß‡∏¢‡πÅ‡∏ö‡∏ö‡πÑ‡∏°‡πà‡∏Ñ‡∏≥‡∏ô‡∏∂‡∏á‡∏ñ‡∏∂‡∏á‡∏ï‡∏±‡∏ß‡∏û‡∏¥‡∏°‡∏û‡πå‡πÉ‡∏´‡∏ç‡πà

    if (error) {
      return res.status(500).send(error.message);
    }

    res.status(200).json(data); // ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡∏õ‡πà‡∏ß‡∏¢‡∏ó‡∏µ‡πà‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤
  } catch (err) {
    res.status(500).send(err.message);
  }
});

// API ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏Å‡∏≤‡∏£‡∏ô‡∏±‡∏î‡∏´‡∏°‡∏≤‡∏¢
app.post("/set-appointment", async (req, res) => {
  try {
    const { patient_id, appointment_date, reminder_time } = req.body;

    // ‡∏û‡∏¥‡∏°‡∏û‡πå‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏à‡∏≤‡∏Å body ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö
    console.log("Request Body:", req.body);

    if (!patient_id) {
      return res
        .status(400)
        .json({ success: false, message: "Patient ID is required" });
    }

    const updateFields = {};
    if (appointment_date) updateFields.appointment_date = appointment_date;
    if (reminder_time) updateFields.reminder_time = reminder_time;

    // ‡∏´‡∏≤‡∏Å‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï
    if (Object.keys(updateFields).length === 0) {
      return res.status(400).json({
        success: false,
        message:
          "At least one of appointment_date or reminder_time must be provided",
      });
    }

    // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
    const { data, error } = await supabase
      .from("patient")
      .update(updateFields)
      .eq("patient_id", patient_id)
      .select();

    // ‡∏´‡∏≤‡∏Å‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏à‡∏≤‡∏Å Supabase
    if (error) {
      console.error("Supabase Error:", error);
      return res
        .status(500)
        .json({ success: false, message: "Database error", error });
    }

    // ‡∏´‡∏≤‡∏Å‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï
    if (data.length === 0) {
      return res.status(404).json({
        success: false,
        message: "Patient not found or no changes made",
      });
    }

    return res.json({
      success: true,
      message: "Appointment updated successfully",
      data,
    });
  } catch (err) {
    // ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° error ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ä‡πà‡∏ß‡∏¢‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏î‡∏µ‡∏ö‡∏±‡πä‡∏Å
    console.error("Server Error:", err);
    res
      .status(500)
      .json({ success: false, message: "Server error", error: err.message });
  }
});

app.get("/all-patients", async (req, res) => {
  try {
    // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡∏õ‡πà‡∏ß‡∏¢‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏à‡∏≤‡∏Å‡∏ï‡∏≤‡∏£‡∏≤‡∏á patient
    const { data, error } = await supabase.from("patient").select("*");

    if (error) {
      return res.status(500).send(error.message);
    }

    // ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡∏õ‡πà‡∏ß‡∏¢‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ
    res.status(200).json(data);
  } catch (err) {
    res.status(500).send(err.message);
  }
});

// API ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡∏õ‡πà‡∏ß‡∏¢
app.put("/update-patient", async (req, res) => {
  try {
    // ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏à‡∏≤‡∏Å‡∏Ñ‡∏≥‡∏Ç‡∏≠
    const { lineUserId, name, email, tel, address, sickness, age, allergic } =
      req.body;

    if (!lineUserId) {
      return res.status(400).json({ message: "Missing lineUserId" });
    }

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    const updates = {};
    if (name) updates.name = name;
    if (email) updates.email = email;
    if (tel) updates.tel = tel;
    if (address) updates.address = address;
    if (sickness) updates.sickness = sickness;
    if (age) updates.age = age;
    if (allergic) updates.allergic = allergic;

    // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô Supabase
    const { data, error } = await supabase
      .from("patient")
      .update(updates)
      .eq("lineid", lineUserId); // ‡πÉ‡∏ä‡πâ lineUserId ‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡∏£‡∏∞‡∏ö‡∏∏‡∏ú‡∏π‡πâ‡∏õ‡πà‡∏ß‡∏¢

    if (error) {
      return res
        .status(500)
        .json({ message: "Error updating patient data", error: error.message });
    }

    return res
      .status(200)
      .json({ message: "Patient data updated successfully", data });
  } catch (err) {
    return res
      .status(500)
      .json({ message: "Server error", error: err.message });
  }
});

app.post("/add-patient", async (req, res) => {
  try {
    const {
      name,
      age,
      lineid,
      allergic,
      sickness,
      address,
      tel,
      email,
      appointment_date,
    } = req.body;

    const { data, error } = await supabase
      .from("patient")
      .insert([
        {
          name,
          age,
          lineid,
          allergic,
          sickness,
          address,
          tel,
          email,
          appointment_date,
        },
      ])
      .select();

    if (error) {
      return res
        .status(500)
        .json({ message: "Error adding patient", error: error.message });
    }

    res.status(201).json(data[0]);
  } catch (err) {
    res.status(500).json({ message: "Server error", error: err.message });
  }
});

// API ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏•‡∏ö‡∏ú‡∏π‡πâ‡∏õ‡πà‡∏ß‡∏¢
app.delete("/delete-patient/:id", async (req, res) => {
  // Use :id to capture the patient ID
  const { id } = req.params;

  try {
    const { error } = await supabase
      .from("patient")
      .delete()
      .eq("patient_id", id);

    if (error) {
      return res
        .status(500)
        .json({ message: "Error deleting patient", error: error.message });
    }

    res.status(200).json({ message: "Patient deleted successfully" });
  } catch (err) {
    res.status(500).json({ message: "Server error", error: err.message });
  }
});


const storage = multer.memoryStorage();
const upload = multer({ storage: multer.memoryStorage() });


 // Use cors once



 app.post("/upload-file", upload.array("files"), async (req, res) => {
  try {
    const files = req.files; // ‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î

    if (!files || files.length === 0) {
      return res.status(400).json({ success: false, message: "No files uploaded" });
    }

    // ‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏õ‡∏¢‡∏±‡∏á Supabase Storage
    for (const file of files) {
      const filePath = `bucket888/${file.originalname}`;

      // ‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå‡∏à‡∏≤‡∏Å Buffer
      const { data, error } = await supabase
        .storage
        .from("bucket888")
        .upload(filePath, file.buffer, {
          contentType: file.mimetype, // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡πÑ‡∏ü‡∏•‡πå (‡πÄ‡∏ä‡πà‡∏ô image/jpeg)
        });

      if (error) {
        throw new Error(`Error uploading file ${file.originalname}: ${error.message}`);
      }

      console.log(`File ${file.originalname} uploaded successfully:`, data);
    }

    res.status(200).json({ success: true, message: "Files uploaded successfully!" });
  } catch (error) {
    console.error("Error uploading files:", error);
    res.status(500).json({ success: false, message: "Error uploading files" });
  }
});

app.delete("/delete/:fileId", async (req, res) => {
  const fileId = req.params.fileId;

  try {
    // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏ü‡∏•‡πå‡∏à‡∏≤‡∏Å‡∏ï‡∏≤‡∏£‡∏≤‡∏á patient_files
    const { data: fileData, error: fileError } = await supabase
      .from("patient_files")
      .select("file_path")
      .eq("file_id", fileId)
      .single();

    if (fileError) {
      throw new Error(`Failed to fetch file info: ${fileError.message}`);
    }

    // ‡∏•‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏à‡∏≤‡∏Å Supabase Storage
    const { data: deleteStorageData, error: deleteStorageError } =
      await supabase.storage.from("bucket888").remove([fileData.file_path]);

    if (deleteStorageError) {
      throw new Error(
        `Failed to delete file from storage: ${deleteStorageError.message}`
      );
    }

    // ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏ü‡∏•‡πå‡∏à‡∏≤‡∏Å‡∏ï‡∏≤‡∏£‡∏≤‡∏á patient_files
    const { data: deleteData, error: deleteError } = await supabase
      .from("patient_files")
      .delete()
      .eq("file_id", fileId);

    if (deleteError) {
      throw new Error(`Failed to delete file info: ${deleteError.message}`);
    }

    res
      .status(200)
      .json({ success: true, message: "File deleted successfully." });
  } catch (error) {
    res.status(500).json({ success: false, message: error.message });
  }
});

// ‚úÖ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå
app.listen(PORT, () => {
  console.log(`üöÄ Server running on http://localhost:${PORT}`);
});
